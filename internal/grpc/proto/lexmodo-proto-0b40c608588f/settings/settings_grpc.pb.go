// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package settings

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SettingsClient is the client API for Settings service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SettingsClient interface {
	SetAnalyticsSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetAnalyticsAccessToken(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetAnalyticsSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetCheckoutSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error)
	SetCheckoutSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetLegalSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error)
	SetLegalSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetStoreWebsite(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error)
	GetStoreSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error)
	SetStoreSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	SetRedirect(ctx context.Context, in *RedirectRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetRedirects(ctx context.Context, in *RedirectListing, opts ...grpc.CallOption) (*ResultResponse, error)
	BlockIP(ctx context.Context, in *BlockedIPRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	DeleteBlockIP(ctx context.Context, in *BlockedIPRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetBlockedIP(ctx context.Context, in *BlockedIPListing, opts ...grpc.CallOption) (*ResultResponse, error)
}

type settingsClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingsClient(cc grpc.ClientConnInterface) SettingsClient {
	return &settingsClient{cc}
}

func (c *settingsClient) SetAnalyticsSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/SetAnalyticsSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetAnalyticsAccessToken(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetAnalyticsAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetAnalyticsSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetAnalyticsSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetCheckoutSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetCheckoutSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) SetCheckoutSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/SetCheckoutSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetLegalSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetLegalSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) SetLegalSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/SetLegalSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetStoreWebsite(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetStoreWebsite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetStoreSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetStoreSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) SetStoreSettings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/SetStoreSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) SetRedirect(ctx context.Context, in *RedirectRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/SetRedirect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetRedirects(ctx context.Context, in *RedirectListing, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetRedirects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) BlockIP(ctx context.Context, in *BlockedIPRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/BlockIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) DeleteBlockIP(ctx context.Context, in *BlockedIPRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/DeleteBlockIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetBlockedIP(ctx context.Context, in *BlockedIPListing, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, "/lexmodo.v1.settings.Settings/GetBlockedIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsServer is the server API for Settings service.
// All implementations must embed UnimplementedSettingsServer
// for forward compatibility
type SettingsServer interface {
	SetAnalyticsSettings(context.Context, *SettingsRequest) (*ResultResponse, error)
	GetAnalyticsAccessToken(context.Context, *SettingsRequest) (*ResultResponse, error)
	GetAnalyticsSettings(context.Context, *SettingsRequest) (*ResultResponse, error)
	GetCheckoutSettings(context.Context, *emptypb.Empty) (*ResultResponse, error)
	SetCheckoutSettings(context.Context, *SettingsRequest) (*ResultResponse, error)
	GetLegalSettings(context.Context, *emptypb.Empty) (*ResultResponse, error)
	SetLegalSettings(context.Context, *SettingsRequest) (*ResultResponse, error)
	GetStoreWebsite(context.Context, *emptypb.Empty) (*ResultResponse, error)
	GetStoreSettings(context.Context, *emptypb.Empty) (*ResultResponse, error)
	SetStoreSettings(context.Context, *SettingsRequest) (*ResultResponse, error)
	SetRedirect(context.Context, *RedirectRequest) (*ResultResponse, error)
	GetRedirects(context.Context, *RedirectListing) (*ResultResponse, error)
	BlockIP(context.Context, *BlockedIPRequest) (*ResultResponse, error)
	DeleteBlockIP(context.Context, *BlockedIPRequest) (*ResultResponse, error)
	GetBlockedIP(context.Context, *BlockedIPListing) (*ResultResponse, error)
	mustEmbedUnimplementedSettingsServer()
}

// UnimplementedSettingsServer must be embedded to have forward compatible implementations.
type UnimplementedSettingsServer struct {
}

func (UnimplementedSettingsServer) SetAnalyticsSettings(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAnalyticsSettings not implemented")
}
func (UnimplementedSettingsServer) GetAnalyticsAccessToken(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnalyticsAccessToken not implemented")
}
func (UnimplementedSettingsServer) GetAnalyticsSettings(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnalyticsSettings not implemented")
}
func (UnimplementedSettingsServer) GetCheckoutSettings(context.Context, *emptypb.Empty) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCheckoutSettings not implemented")
}
func (UnimplementedSettingsServer) SetCheckoutSettings(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCheckoutSettings not implemented")
}
func (UnimplementedSettingsServer) GetLegalSettings(context.Context, *emptypb.Empty) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLegalSettings not implemented")
}
func (UnimplementedSettingsServer) SetLegalSettings(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLegalSettings not implemented")
}
func (UnimplementedSettingsServer) GetStoreWebsite(context.Context, *emptypb.Empty) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStoreWebsite not implemented")
}
func (UnimplementedSettingsServer) GetStoreSettings(context.Context, *emptypb.Empty) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStoreSettings not implemented")
}
func (UnimplementedSettingsServer) SetStoreSettings(context.Context, *SettingsRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStoreSettings not implemented")
}
func (UnimplementedSettingsServer) SetRedirect(context.Context, *RedirectRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRedirect not implemented")
}
func (UnimplementedSettingsServer) GetRedirects(context.Context, *RedirectListing) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRedirects not implemented")
}
func (UnimplementedSettingsServer) BlockIP(context.Context, *BlockedIPRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockIP not implemented")
}
func (UnimplementedSettingsServer) DeleteBlockIP(context.Context, *BlockedIPRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBlockIP not implemented")
}
func (UnimplementedSettingsServer) GetBlockedIP(context.Context, *BlockedIPListing) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockedIP not implemented")
}
func (UnimplementedSettingsServer) mustEmbedUnimplementedSettingsServer() {}

// UnsafeSettingsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingsServer will
// result in compilation errors.
type UnsafeSettingsServer interface {
	mustEmbedUnimplementedSettingsServer()
}

func RegisterSettingsServer(s grpc.ServiceRegistrar, srv SettingsServer) {
	s.RegisterService(&Settings_ServiceDesc, srv)
}

func _Settings_SetAnalyticsSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).SetAnalyticsSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/SetAnalyticsSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).SetAnalyticsSettings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetAnalyticsAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetAnalyticsAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetAnalyticsAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetAnalyticsAccessToken(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetAnalyticsSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetAnalyticsSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetAnalyticsSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetAnalyticsSettings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetCheckoutSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetCheckoutSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetCheckoutSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetCheckoutSettings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_SetCheckoutSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).SetCheckoutSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/SetCheckoutSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).SetCheckoutSettings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetLegalSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetLegalSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetLegalSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetLegalSettings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_SetLegalSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).SetLegalSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/SetLegalSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).SetLegalSettings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetStoreWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetStoreWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetStoreWebsite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetStoreWebsite(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetStoreSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetStoreSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetStoreSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetStoreSettings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_SetStoreSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).SetStoreSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/SetStoreSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).SetStoreSettings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_SetRedirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).SetRedirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/SetRedirect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).SetRedirect(ctx, req.(*RedirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetRedirects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectListing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetRedirects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetRedirects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetRedirects(ctx, req.(*RedirectListing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_BlockIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).BlockIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/BlockIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).BlockIP(ctx, req.(*BlockedIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_DeleteBlockIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).DeleteBlockIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/DeleteBlockIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).DeleteBlockIP(ctx, req.(*BlockedIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetBlockedIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockedIPListing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetBlockedIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lexmodo.v1.settings.Settings/GetBlockedIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetBlockedIP(ctx, req.(*BlockedIPListing))
	}
	return interceptor(ctx, in, info, handler)
}

// Settings_ServiceDesc is the grpc.ServiceDesc for Settings service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Settings_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lexmodo.v1.settings.Settings",
	HandlerType: (*SettingsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAnalyticsSettings",
			Handler:    _Settings_SetAnalyticsSettings_Handler,
		},
		{
			MethodName: "GetAnalyticsAccessToken",
			Handler:    _Settings_GetAnalyticsAccessToken_Handler,
		},
		{
			MethodName: "GetAnalyticsSettings",
			Handler:    _Settings_GetAnalyticsSettings_Handler,
		},
		{
			MethodName: "GetCheckoutSettings",
			Handler:    _Settings_GetCheckoutSettings_Handler,
		},
		{
			MethodName: "SetCheckoutSettings",
			Handler:    _Settings_SetCheckoutSettings_Handler,
		},
		{
			MethodName: "GetLegalSettings",
			Handler:    _Settings_GetLegalSettings_Handler,
		},
		{
			MethodName: "SetLegalSettings",
			Handler:    _Settings_SetLegalSettings_Handler,
		},
		{
			MethodName: "GetStoreWebsite",
			Handler:    _Settings_GetStoreWebsite_Handler,
		},
		{
			MethodName: "GetStoreSettings",
			Handler:    _Settings_GetStoreSettings_Handler,
		},
		{
			MethodName: "SetStoreSettings",
			Handler:    _Settings_SetStoreSettings_Handler,
		},
		{
			MethodName: "SetRedirect",
			Handler:    _Settings_SetRedirect_Handler,
		},
		{
			MethodName: "GetRedirects",
			Handler:    _Settings_GetRedirects_Handler,
		},
		{
			MethodName: "BlockIP",
			Handler:    _Settings_BlockIP_Handler,
		},
		{
			MethodName: "DeleteBlockIP",
			Handler:    _Settings_DeleteBlockIP_Handler,
		},
		{
			MethodName: "GetBlockedIP",
			Handler:    _Settings_GetBlockedIP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "settings.proto",
}
